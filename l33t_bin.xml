<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- Inspired by Pwar's mudbin http://mb.aardwolfboot.com / https://github.com/hudmond/hudmond.github.io/blob/master/Aardwolf_mudbin_v1.0.1.zip -->
<!-- Plugin "CopyScript" generated by Plugin Wizard -->
<!-- Amended slightly by Nick Gammon, from Worstje's version, on 17 Feb 2008 -->
<!-- Refactored by Fiendish for the Aardwolf client package-->

<muclient>
<plugin
   name="l33t_bin"
   author="Ruhamah"
   id="1337b0721cd04ee582e2e1ca"
   language="Lua"
   purpose="Copies and posts to a l33t bin link"
   save_state="n"
   date_written="2020-05-16"
   requires="4.00"
   version="0.02"
   >

<description trim="y">
<![CDATA[
      l33t_bin (v0.01) by Ruhamah (https://aard.l33t.xyz)

Copies text from the output window to the clipboard, with
Aardwolf colour codes. Pastes to l33t bin at:
https://l33t.xyz/aardbin

Usage:

   Highlight text and then [Ctrl+P]
   > Copy and posts to l33t bin (like Ctrl+C but different)

   l33t bin help
   lbin help
   > Displays help

   l33t bin list
   lbin list
   > Lists out your previously created pastes

   PREMIUM ONLY:

   l33t bin login
   lbin login
   > Generates a login URL to allow you to view and edit your pastes

]]>
</description>

</plugin>

<aliases>
  <alias
   enabled="y"
   group="l33t"
   match="^ *(lbin|l33t bin) *list *$"
   regexp="y"
   script="l33t_bin_list"
   sequence="100"
  >
  </alias>
  <alias
   enabled="y"
   group="l33t"
   match="^ *(lbin|l33t bin) *login *$"
   regexp="y"
   script="l33t_bin_login"
   sequence="100"
  >
  </alias>
  <!--  Plugin help  -->
  <alias
   enabled="y"
   group="l33t"
   match="l33t_bin:help"
   script="OnHelp"
   sequence="999"
  >
  </alias>
  <alias
   enabled="y"
   group="l33t"
   match="^ *l33t bin *(help)? *$"
   regexp="y"
   sequence="999"
   script="OnHelp"
  >
  </alias>
  <alias
   enabled="y"
   group="l33t"
   match="^ *lbin *(help)? *$"
   regexp="y"
   sequence="999"
   script="OnHelp"
  >
  </alias>
</aliases>

<!--  Script  -->

<script>
<![CDATA[


-- Globals


PLUGIN_ID = GetPluginID()
PLUGIN_NAME = GetPluginInfo(PLUGIN_ID, 1)
PLUGIN_AUTHOR = GetPluginInfo(PLUGIN_ID, 2)
PLUGIN_VERSION = GetPluginInfo(PLUGIN_ID, 19)
PLUGIN_NUM_TRIGGERS = GetPluginInfo(PLUGIN_ID, 9)
PLUGIN_NUM_ALIASES = GetPluginInfo(PLUGIN_ID, 10)
PLUGIN_NUM_TIMERS = GetPluginInfo(PLUGIN_ID, 11)

PLUGIN_URL = 'https://aard.l33t.xyz'


-- Other plugins


local L33T_BIN_POST_URL = 'https://l33t.xyz/api/aardwolf/pastebin'
local L33T_BIN_LIST_URL = 'https://l33t.xyz/api/aardwolf/pastebin/list'
local L33T_BIN_LOGIN_URL = 'https://l33t.xyz/api/aardwolf/pastebin/login'

local PLUGIN_ID_L33T_PLUGIN_MANAGER = 'baa6825f5a7dd47512795deb'
local PLUGIN_ID_L33T_BIN = '1337b0721cd04ee582e2e1ca'
local PLUGIN_ID_GMCP_HANDLER = '3e7dedbe37e44942dd46d264'


-- Locals and Imports


local async = require 'async'
require 'json'


local username


-- Core Functions


function determineHttpMode(url)
    local http_mode = string.sub(url, 1, 5)
    if http_mode == 'https' then
        http_mode = string.upper(http_mode)
    else
        http_mode = 'HTTP'
    end

    return http_mode
end


-- functions for handling Aardwolf color codes
dofile(GetPluginInfo(PLUGIN_ID, 20) .. 'aardwolf_colors.lua')


function OnPluginListChanged()
   dofile 'lua/aard_requirements.lua'
end


function l33t_bin_list(name, line, wildcards)
    if not username then
        any, username = CallPlugin(PLUGIN_ID_GMCP_HANDLER, 'gmcpval', 'char.base.name')
    end

    local url = L33T_BIN_LIST_URL
    local http_mode = determineHttpMode(url)
    local timeout_secs = 15
    local timeout_callback = nil
    local payload = json.encode({
        ['username'] = username,
    })

    async.doAsyncRemoteRequest(
       url,
       handle_list_response,
       http_mode,
       timeout_secs,
       timeout_callback,
       payload
    )
end


function l33t_bin_login(name, line, wildcards)
   local any, isUnlocked = CallPlugin(PLUGIN_ID_L33T_PLUGIN_MANAGER, 'isPremiumUnlocked')

   if isUnlocked then
      local any, token = CallPlugin(PLUGIN_ID_L33T_PLUGIN_MANAGER, 'getToken')

      local url = L33T_BIN_LOGIN_URL
      local http_mode = determineHttpMode(url)
      local timeout_secs = 15
      local timeout_callback = nil
      local payload = json.encode({
         ['token'] = token
      })

      async.doAsyncRemoteRequest(
         url,
         handle_login_response,
         http_mode,
         timeout_secs,
         timeout_callback,
         payload
      )

   end
end


function handle_list_response(retval, responseContent, status, headers, full_status, request_url)
    if tonumber(status) == 200 then
        local payload = json.decode(responseContent)
        print('The following l33t bin pastes are available:')
        for i, url in orderedPairs(payload.urls) do
            ColourTell('CornFlowerBlue', '', '- ')
            Hyperlink(url, url, '[l33t_bin: ' .. url .. ']', 'cornflowerblue', '', true)
            print('')
        end
    else
        print('Failed to retrieve list of previous l33t bin pastes.')
    end
end


function handle_login_response(retval, responseContent, status,
headers, full_status, request_url)
   if tonumber(status) == 200 then
      local payload = json.decode(responseContent)
      print('Succesfully logged in to l33t bin!')
      local url = payload.login_url
      Hyperlink(
         url,
         'Click to continue to l33t bin (' .. url .. ')',
         'Click to continue to l33t bin (' .. url .. ')',
         'cornflowerblue',
         '',
         true
      )
      print('')
   else
      print('Failed to log in to l33t bin.')
   end
end


-- Thank you, Shaun Biggs, for taking your time to write the CopyScript
-- (formerly Copy2) function below. It was slightly altered by me to suit
-- my usage (wordwrapped lines and no \r\n at start of selection). -- Nick Gammon
-- And then I ripped out its heart because handling color is its own beast. :) -- Fiendish
-- And then I took the whole thing and used it for my mudbin ;D --Pwar
-- And then I took this and used it for my l33t bin ;D --Ruhamah (L33t.xyz)


function copyAndPostSelection(name, line, wildcards)
   first_line, last_line, first_column, last_column = getSelectionParameters()

   -- find selection in output window, if any

   if first_line <= 0 then
      -- nothing selected, do normal copy
      -- if nothing to copy from output window
      DoCommand('copy')
   else
      local cpstr = copySelection(first_line, last_line, first_column, last_column)

      -- finally can set clipboard contents
      postText(cpstr)
   end
end


function getSelectionParameters()
   local first_line = GetSelectionStartLine()
   local last_line = math.min(GetSelectionEndLine(), GetLinesInBufferCount ())
   local first_column = GetSelectionStartColumn()
   local last_column = GetSelectionEndColumn()

   return first_line, last_line, first_column, last_column
end


function copySelection(first_line, last_line, first_column, last_column)
    cpstr = ''

    -- iterate to build up copy text
    for line = first_line, last_line do
        if line < last_line then
            cpstr = cpstr .. StylesToColoursOneLine(GetStyleInfo(line), first_column, GetLineInfo(line).length)
            first_column = 1

            -- Is this a new line or merely the continuation of a paragraph?
            if GetLineInfo (line, 3) then
               cpstr = cpstr .. "\r\n"
            end  -- new line
        else
            cpstr = cpstr .. StylesToColoursOneLine(GetStyleInfo(line), first_column, last_column - 1)
        end
    end

    -- Get rid of a spurious extra new line at the start.
    if cpstr:sub(1, 2) == "\r\n" then
        cpstr = cpstr:sub(3)
    end

    return cpstr
end


function postText(text)
    if not username then
        any, username = CallPlugin(PLUGIN_ID_GMCP_HANDLER, 'gmcpval', 'char.base.name')
    end

    local url = L33T_BIN_POST_URL
    local http_mode = determineHttpMode(url)
    local timeout_secs = 15
    local timeout_callback = nil
    local payload = json.encode({
        ['username'] = username,
        ['text'] = text,
    })

    async.doAsyncRemoteRequest(
       url,
       handle_upload_complete,
       http_mode,
       timeout_secs,
       timeout_callback,
       payload
    )
end


function handle_upload_complete(retval, responseContent, status, headers, full_status, request_url)
    if tonumber(status) == 200 then
        local payload = json.decode(responseContent)
        local link = payload.url
        SetClipboard(link)
        ColourNote('CornFlowerBlue', '', '*** Posted clipboard contents to l33t_bin')
        ColourTell('CornFlowerBlue', '', '*** ')
        Hyperlink(link, link, '[l33t_bin link]', 'cornflowerblue', '', true)
        ColourTell('CornFlowerBlue', '', ' has been copied. Press CTRL+V to paste.')
        print('')
    else
        print('Failed to post clipboard contents to site. Error code ' .. status)
    end
    --print(status)
    --print(page)
end


AcceleratorTo ('Ctrl+P', 'CallPlugin ("' .. PLUGIN_ID_L33T_BIN .. '", "copyAndPostSelection", "")', sendto.script)


-- Help


function OnHelp (sName, sLine, wildcards)
    Note(GetPluginInfo(GetPluginID(), 3))
end


-- Plugin Lifecycle


function OnPluginInstall()
    printSeparator()

    ColourTell(
        'CornFlowerBlue', '', (
            'Loaded ' .. PLUGIN_NAME
            .. ' (v' .. PLUGIN_VERSION .. ')'
            .. ' by ' .. PLUGIN_AUTHOR
            .. ' ('
        )
    )
    printPluginLink()

    ColourTell(
        'CornFlowerBlue', '', (
            ').\n'
            .. 'Loaded '
            .. PLUGIN_NUM_TRIGGERS .. ' triggers, '
            .. PLUGIN_NUM_ALIASES .. ' aliases, '
            .. PLUGIN_NUM_TIMERS .. ' timers.\n\n'
        ),

        'CornFlowerBlue', '', 'Select text in the main window and press Ctrl+P to use.\n\n',

        'CornFlowerBlue', '', 'Type "',
        'MediumSeaGreen', '', 'l33t bin help',
        'CornFlowerBlue', '', '".\n'
    )

    printSeparator()
end


-- Util Functions


--[[
Ordered table iterator, allow to iterate on the natural order of the keys of a
table.

From http://lua-users.org/wiki/SortedIteration
]]

function __genOrderedIndex( t )
    local orderedIndex = {}
    for key in pairs(t) do
        table.insert( orderedIndex, key )
    end
    table.sort( orderedIndex )
    return orderedIndex
end

function orderedNext(t, state)
    -- Equivalent of the next function, but returns the keys in the alphabetic
    -- order. We use a temporary ordered key table that is stored in the
    -- table being iterated.

    local key = nil
    --print("orderedNext: state = "..tostring(state) )
    if state == nil then
        -- the first time, generate the index
        t.__orderedIndex = __genOrderedIndex( t )
        key = t.__orderedIndex[1]
    else
        -- fetch the next value
        for i = 1,table.getn(t.__orderedIndex) do
            if t.__orderedIndex[i] == state then
                key = t.__orderedIndex[i+1]
            end
        end
    end

    if key then
        return key, t[key]
    end

    -- no more value to return, cleanup
    t.__orderedIndex = nil
    return
end

function orderedPairs(t)
    -- Equivalent of the pairs() function on tables. Allows to iterate
    -- in order
    return orderedNext, t, nil
end
--[[
End Ordered Table functions
]]


function printSeparator()
    ColourTell(
        'CornFlowerBlue',
        '',
        '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n'
    )
end


function printPluginLink()
    Hyperlink(PLUGIN_URL, PLUGIN_URL, '', '', '', 1)
end


]]>
</script>
</muclient>
